# Immutable
- 망가뜨리고 싶어도 망가지지 않는다.

## Immutable 이란?
- Immutable은 '불변의', '변하는 것이 없는'이라는 뜻입니다. 즉, 여러개의 쓰레드가 어떤 인스턴스에 접근을 하더라도 내부 상태가 변하지 않는다 라고 생각하면 됩니다.
- 간단한 예로 String.class는 문자열내용을 변경하는 메소드가 없습니다. 그러므로 여러 쓰레드가 접근하더라도 내용이나 상태는 변하지 않으므로 Immutable하다 라고 볼수 있습니다.
- Immutable 속성을 가지고 있으면 그 인스턴스에 접근하는 시간이 걸리는 베타제어를 할필요가 없기 때문에 성능상에서도 이점이 있습니다.
- Immutable 역할은 필드 값을 변경할 수 없고 필드 내용을 변경하는 메소드도 가지고 있지 않은 클래스입니다. 즉, 인스턴스 작성 후 절대 상태변화를 하지 않습니다.

## Immutable은 어떤 경우에 쓰일까?
- 인스턴스 생성 후 상태가 변하지 않을 때
    - 인스턴스가 생성 후 인스턴스 상태가 변하지 않는 것은 필드 내 데이터를 변경할 수 있는 Setter함수가 없어야 하며 final이 선언되 있어야 합니다.
    - 그러나 위의 경우 처럼 되어 있더라도 필드 값 자체는 변하지 않더라도 필드가 참조하고 있는 곳의 인스턴스가 변할 수 있기 때문에 Immutable이 아닐수도 있습니다.
- 인스턴스가 공유되어 빈번하게 엑세스 될 때
    - Immutable의 특징은 '[Sycronized]로 가드할 필요가 없다'임으로 안정성과 생존성을 유지하면서 수행 능력을 높일 수 있습니다.
    - 만일 이러한 특징을 가지는 메소드 혹은 클래스랑 아닌 클래스를 비교하게 되면 빈번하게 쓰일 경우 Immutable을 속성을 가지고 있는 함수나 메소드가 성능에서 많은 이점을 가져올 수 있습니다.
    - 간단한 예로, String.class와 StringBuffer.class를 예로 들수 있습니다. StringBuffer.class는 mutable한 클래스로 자유롭게 문자열을 수정할 수 있습니다. 그리고 안전을 위해 고쳐쓸땐 적절히 Sycronized를 걸면 됩니다. 그러나 String.class는 Immutable함으로 String 인스턴스가 표시하고 있는 문자열은 수정할 수 없지만, String.class를 접근하는 메소드는 Syncronized 하지 않음으로 빠른 참조가 가능해집니다. 
    - 위 예시를 통해서 java에서는 내용이 자주 변경되면 StringBuffer클래스를 변경되지 않는 다면 String.class를 사용하는게 일반적입니다.
- 불변성을 지키기 위해(재사용성)
    - 불변성은 매우 예민하여 조금만 소스를 수정해도 불변성을 잃기 쉽습니다.
    - Immutable을 전제로 Sycronized를 제거한 경우 불변성을 상실하는 순간 클래스 안정성까지 잃을 수 있으므로 조심해야 합니다.

## final 의미
- final 클래스 : 클래스를 확장할 수 없습니다. 즉, 상속 받게 되더라도 메소드들을 @Override하지 못한다는 의미입니다.
- final 메소드 : @Override를 할수 없으며 서브 클래스의 메소드로 은폐(Hide)됩니다.
- final 필드 : final 필드는 단 한번만 대입할 수 있습니다.
